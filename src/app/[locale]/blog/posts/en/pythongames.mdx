---
title: "Learning Python by Building Games: A Progressive Journey"
publishedAt: "2022-09-16"
summary: "A hands-on approach to learning Python through game development, starting with simple projects and scaling up to more complex challenges."
tag: "Learning"
---

Learning Python can be overwhelming without a clear roadmap. To make it fun and engaging, I decided to learn by building games—starting with simple projects and progressively increasing complexity. This blog post showcases four projects that helped me grasp core programming concepts, culminating in a deeper understanding of Python.

---

## Project 1: Rock, Paper, Scissors

This classic game was my first foray into Python programming. It taught me about conditionals, loops, and user input handling.

<CodeBlock className="my-24"
    compact
    codeInstances={[
        {
            code: `import random

choices = ['rock', 'paper', 'scissors']

while True:
    user_choice = input("Choose rock, paper, or scissors: ").lower()
    if user_choice not in choices:
        print("Invalid choice. Try again.")
        continue

    computer_choice = random.choice(choices)
    print(f"Computer chose: {computer_choice}")

    if user_choice == computer_choice:
        print("It's a tie!")
    elif (user_choice == 'rock' and computer_choice == 'scissors') or \
         (user_choice == 'scissors' and computer_choice == 'paper') or \
         (user_choice == 'paper' and computer_choice == 'rock'):
        print("You win!")
    else:
        print("You lose!")

    play_again = input("Play again? (yes/no): ").lower()
    if play_again != 'yes':
        break`,
            label: 'Rock, Paper, Scissors',
            language: 'python'
        },
    ]}
    copyButton
/>

**Concepts Learned:**
- **Conditionals:** Comparing user and computer choices.
- **Randomization:** Using `random.choice` for unpredictable outcomes.
- **Loops:** Repeating the game until the user decides to quit.

---

## Project 2: Tic Tac Toe

Stepping up, I created a two-player Tic Tac Toe game. This project introduced me to functions, lists, and basic algorithms for checking game states.

<CodeBlock className="my-24"
    compact
    codeInstances={[
        {
            code: `def print_board(board):
    for row in board:
        print(" | ".join(row))
    print()

def check_winner(board):
    for row in board:
        if row[0] == row[1] == row[2] and row[0] != " ":
            return row[0]
    for col in range(3):
        if board[0][col] == board[1][col] == board[2][col] and board[0][col] != " ":
            return board[0][col]
    if board[0][0] == board[1][1] == board[2][2] and board[0][0] != " ":
        return board[0][0]
    if board[0][2] == board[1][1] == board[2][0] and board[0][2] != " ":
        return board[0][2]
    return None

board = [[" "] * 3 for _ in range(3)]
current_player = "X"

while True:
    print_board(board)
    row, col = map(int, input(f"Player {current_player}, enter row and column (0-2): ").split())
    if board[row][col] != " ":
        print("Invalid move. Try again.")
        continue
    board[row][col] = current_player
    winner = check_winner(board)
    if winner:
        print_board(board)
        print(f"Player {winner} wins!")
        break
    current_player = "O" if current_player == "X" else "X"`,
            label: 'Tic Tac Toe',
            language: 'python'
        },
    ]}
    copyButton
/>

**Concepts Learned:**
- **Nested Lists:** Representing the game board as a 2D list.
- **Functions:** Modularizing game logic (e.g., printing the board, checking winners).
- **Input Validation:** Ensuring valid moves.

---

## Project 3: Hangman

Hangman required managing strings, dictionaries, and loops to track guessed letters and remaining attempts.

<CodeBlock className="my-24"
    compact
    codeInstances={[
        {
            code: `import random

words = ["python", "hangman", "developer", "programming"]
word = random.choice(words)
guessed = set()
attempts = 6

while attempts > 0:
    display = [letter if letter in guessed else "_" for letter in word]
    print(" ".join(display))

    if "_" not in display:
        print("You win!")
        break

    guess = input("Guess a letter: ").lower()
    if guess in guessed:
        print("You already guessed that letter.")
    elif guess in word:
        guessed.add(guess)
        print("Correct!")
    else:
        attempts -= 1
        print(f"Incorrect. You have {attempts} attempts remaining.")
else:
    print(f"You lose! The word was: {word}")`,
            label: 'Hangman',
            language: 'python'
        },
    ]}
    copyButton
/>

**Concepts Learned:**
- **Sets:** Tracking guessed letters efficiently.
- **String Manipulation:** Revealing correct letters in the word.
- **Game Logic:** Managing player attempts and game progression.

---

## Project 4: Pirate’s Treasure Chest

For my most complex project, I created a treasure hunt game with a simple grid-based map, hidden treasures, and dynamic game mechanics.

<CodeBlock className="my-24"
    compact
    codeInstances={[
        {
            code: `import random

def create_map(size):
    return [["." for _ in range(size)] for _ in range(size)]

def place_treasure(map, num_treasures):
    for _ in range(num_treasures):
        x, y = random.randint(0, len(map) - 1), random.randint(0, len(map) - 1)
        map[x][y] = "T"

def play_game(map):
    size = len(map)
    for _ in range(10):
        x, y = map(int, input("Enter coordinates (row, column): ").split())
        if map[x][y] == "T":
            print("You found a treasure!")
            map[x][y] = "."
        else:
            print("No treasure here.")
        print_map(map)

def print_map(map):
    for row in map:
        print(" ".join(row))

size = 5
map = create_map(size)
place_treasure(map, 3)
play_game(map)`,
            label: 'Pirate’s Treasure Chest',
            language: 'python'
        },
    ]}
    copyButton
/>

**Concepts Learned:**
- **Grid Management:** Creating and manipulating 2D maps.
- **Random Placement:** Strategically placing treasures on the map.
- **Game Dynamics:** Balancing exploration and gameplay mechanics.

---

## Reflections

Building these games not only made learning Python enjoyable but also helped me understand how to break problems into smaller components. From basic conditionals in Rock, Paper, Scissors to advanced logic in Pirate’s Treasure Chest, each project reinforced essential programming concepts.